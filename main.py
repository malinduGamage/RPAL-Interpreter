# Usage:
# python main.py [-ast] [-t] [-ft] [-st] [-r] [-rast] file_name

# Arguments:
# file_name: The name of the RPAL file to interpret.

# Optional Switches:
# -ast: Print the Abstract Syntax Tree (AST) for the given RPAL program.
# -t: Print the tokens generated by the lexical analyzer for the given RPAL program.
# -ft: Print the filtered tokens generated by the screener for the given RPAL program.
# -st: Print the Standard Tree for the given RPAL program. (Not yet implemented)
# -r: Execute the original RPAL interpreter on the given RPAL program file (file should be in rpal_tests/rpal_source).
# -rast: Execute the original RPAL interpreter on the given RPAL program file and print the AST. (file should be in rpal_tests/rpal_source)

# Examples:
# To interpret an RPAL program:
# python main.py example.rpal

# To print the Abstract Syntax Tree (AST):
# python main.py -ast example.rpal

# To print the tokens:
# python main.py -t example.rpal

# To print the filtered tokens:
# python main.py -ft example.rpal

# To execute the original RPAL interpreter on a file and print the AST:
# python main.py -rast example.rpal


import sys
import platform
from interpreter.execution_engine import Evaluator
from rpal_tests.rpal_exe import rpal_exe
from parser.build_standard_tree import StandardTree
from utils.node import Node
from utils.AST_printer import print_AST
from utils.test_program import test_programs


def main():
    """
    Main function of the interpreter.

    Args:
        sys.argv (list): Command line arguments passed to the interpreter.

    Returns:
        None

    Raises:
        ValueError: If the number of command line arguments is less than 2.

    """
    s = StandardTree()
    """ tree1 = Node("@")
    tree1.add_child(Node("e2"))
    tree1.add_child(Node("n"))
    tree1.add_child(Node("e1"))

    s1 = standard_tree(tree1)
    s1.build_standard_tree()

    print_AST(tree1)

    tree2 = Node("aug")
    tree2.add_child(Node("e2"))
    tree2.add_child(Node("e1"))

    s2 = standard_tree(tree2)
    s2.build_standard_tree()
    print_AST(tree2)

    tree3 = Node("rec")
    tree3.add_child(Node("="))
    tree3.children[0].children = [Node("x"),Node("e")]
    

    s3 = standard_tree(tree3)
    s3.build_standard_tree()
    print_AST(tree3) 

    tree4 = Node("where")
    tree4.children = [Node("p"),Node("=")]
    tree4.children[1].children = [Node("x"),Node("e")]
    

    s4 = standard_tree(tree4)
    s4.build_standard_tree()
    print_AST(tree4) 

    tree5 = Node("neg")
    tree5.children = [Node("e")]
    
    s5 = standard_tree(tree5)
    s5.build_standard_tree()
    print_AST(tree5)

    tree6 = Node("->")
    tree6.children = [Node("b"),Node("t"),Node("e")]
    
    s6 = standard_tree(tree6)
    s6.build_standard_tree()
    print_AST(tree6)

    tree7 = Node("not")
    tree7.children = [Node("e")]

    s.build_standard_tree(tree7)
    print_AST(tree7) """

    tree8 = Node("within")
    tree8.children = [Node("="),Node("=")]
    tree8.children[0].children = [Node("x1"),Node("e1")]
    tree8.children[1].children = [Node("x2"),Node("e2")]

    print_AST(tree8)
    
    s.build_standard_tree(tree8)
    print_AST(tree8) 


    # Check if there are enough command-line arguments
    if len(sys.argv) < 2:
        print(
            "Usage: python main.py [-ast] [-t] [-ft] [-st] [-r] [-rast] file_name ")
        return

    # Get the filename from the command-line arguments
    if len(sys.argv) >= 3:
        file_name = sys.argv[2]
    else:
        file_name = sys.argv[1]

    # Create an instance of the Evaluator class
    evaluator = Evaluator()

    # Interpret the file
    evaluator.interpret(file_name)

    # Check if the -ast switch is provided
    if len(sys.argv) >= 3:
        if sys.argv[1] == "-ast":
            # Print the Abstract Syntax Tree
            handle_ast_option(evaluator)
        elif sys.argv[1] == "-t":
            # Print the tokens
            handle_tokens_option(evaluator)
        elif sys.argv[1] == "-ft":
            # Print the filtered tokens
            handle_filtered_tokens_option(evaluator)
        elif sys.argv[1] == "-st":
            # Print the standard tree
            # handle_standard_tree_option(evaluator)
            print("Not yet implemented")
        elif sys.argv[1] == "-r":
            # Print the original RPAL evaluation(file should be in rpal_test/rpal_source file)
            try:
                handle_original_rpal_eval(file_name)
            except:
                print(
                    "Error in original RPAL evaluation\n(file should be in rpal_test/rpal_source file)")
        elif sys.argv[1] == "-rast":
            # Print the original RPAL evaluation(file should be in rpal_test/rpal_source file)
            try:
                handle_original_rpal_ast(file_name)
            except:
                print("Error in original RPAL evaluation\n(file should be in rpal_test/rpal_source file)")

    else:
        # Default behavior: Evaluate the program
        # handle_default_behavior(evaluator)
        print("Not yet implemented")
    """ l = []
    for program in test_programs:
        l.append(rpal_exe(program,True))
    print(l) """


def handle_ast_option(evaluator):
    """
    Prints the Abstract Syntax Tree for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the abstract syntax tree
    evaluator.print_AST()


def handle_standard_tree_option(evaluator):
    """
    Prints the Standard Tree for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the standard tree
    evaluator.print_standard_tree()


def handle_default_behavior(evaluator):
    """
    Prints the default behavior for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code for default behavior
    print("Not yet implemented")


def handle_tokens_option(evaluator):
    """
    Prints the tokens for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the tokens
    evaluator.print_tokens()


def handle_filtered_tokens_option(evaluator):
    """
    Prints the filtered tokens for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the filtered tokens
    evaluator.print_filtered_tokens()


def handle_original_rpal_eval(file_name):
    """
    Handles the original RPAL evaluation.

    Args:
        file_name (str): The name of the file to evaluate.

    Returns:
        None
    """
    if platform.system() == "Windows":
        rpal_exe(file_name)
    else:
        print("Original RPAL evaluation is not supported on this operating system.")


def handle_original_rpal_ast(file_name):
    """
    Handles the original RPAL AST generation.

    Args:
        file_name (str): The name of the file to generate AST.

    Returns:
        None
    """
    if platform.system() == "Windows":
        rpal_exe(file_name, True)
    else:
        print("Original RPAL AST generation is not supported on this operating system.")


if __name__ == "__main__":
    main()
